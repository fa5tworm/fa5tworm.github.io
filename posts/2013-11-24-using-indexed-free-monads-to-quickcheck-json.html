<!DOCTYPE html>
<html>
  
<!-- Mirrored from blog.ocharles.org.uk/posts/2013-11-24-using-indexed-free-monads-to-quickcheck-json.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:59 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Using indexed free monads to QuickCheck JSON</title>
    <!-- <link rel="stylesheet" type="text/css" href="/css/reset.css" /> -->
    <!-- <link rel="stylesheet" type="text/css" href="/css/typography.css" /> -->
    <link rel="stylesheet" type="text/css" href="../css/syntax-highlighting.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../posts.rss">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,100" rel="stylesheet" type="text/css">
    <style>
    /*! Typebase.less v0.1.0 | MIT License */
    /* Setup */
    html {
      /* Change default typefaces here */
      font-size: 125%;
      -webkit-font-smoothing: antialiased;
      font-family: 'Roboto Slab', serif;
      font-weight: 300;
    }
    /* Copy & Lists */
    p, pre {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 0;
    }
    ul,
    ol {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    ul li,
    ol li {
      line-height: 1.5rem;
    }
    ul ul,
    ol ul,
    ul ol,
    ol ol {
      margin-top: 0;
      margin-bottom: 0;
    }
    blockquote {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* Headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      /* Change heading typefaces here */
      font-weight: 100;
      margin-top: 1.5rem;
      margin-bottom: 0;
      line-height: 1.5rem;
    }
    h1 {
      font-size: 3.242rem;
      line-height: 4.5rem;
      margin-top: 3rem;
      text-align: center;
      padding-bottom: 1.5rem;
    }
    h2 {
      font-size: 2.828rem;
      line-height: 3rem;
      margin-top: 3rem;
    }
    h3 {
      font-size: 1.414rem;
    }
    h4 {
      font-size: 0.707rem;
    }
    h5 {
      font-size: 0.4713333333333333rem;
    }
    h6 {
      font-size: 0.3535rem;
    }
    /* Tables */
    table {
      margin-top: 1.5rem;
      border-spacing: 0px;
      border-collapse: collapse;
    }
    table td,
    table th {
      padding: 0;
      line-height: 33px;
    }
    /* Leading paragraph text */
    .lead {
      font-size: 1.414rem;
    }
    /* Hug the block above you */
    .hug {
      margin-top: 0;
    }

    html {
      background: #eae3cb;
    }
    body {
      background-color: #fcf4dc;
      width: 40em;
      margin: 0 auto 2em;
      padding: 2em 3em;
      border: 1px solid #d9d2ba;
      border-top: none;
      color: #111;
    }
    h1 {
      border-bottom: 1px solid #555;
      /*text-align: center;
      padding-bottom: 10px;*/
    }
    /* h2,h3 { margin-top: 2em } */
    ul#icons {
      position: absolute;
      top: 10px;
      right: 10px;
      list-style-type: none;
      text-align: right;
    }
    ul#icons img { width: 16px; vertical-align: middle; }
    ul#icons a { color: transparent; font-style: italic; font-size: small; }
    ul#icons li:hover a { color: #aaa; text-decoration: none !important}
    #TOC { display: none; }
    pre {
      border-bottom: 1px dotted #d9d2ba;
      border-top: 1px dotted #d9d2ba;
    }
     a {
         text-decoration: none;
     }
    </style>
  </head>
  <body>
    <h1>Using indexed free monads to QuickCheck JSON</h1>
<p>One of the most satisfying parts of my job is the moment when, after months of devout studying into abstract constructions, I can finally apply what I have learnt to solve problems in the real world. One of these rare moments occured last week, and I’m eager to share what I’ve learnt with you. I’ll walk you through a definition of the problem, my first attempts at solving it, and then at the end we’ll see how I used indexed free monads to easily construct a DSL that produces an either more powerful solution. On with the show!</p>
<h2 id="the-problem">The Problem</h2>
<p>I have been tasked with building a web service for our frontend AngularJS application to talk to. The frontend developer is going to be manually binding to the output of my web service, so it’s paramount that the encoding never changes. Being JavaScript, the obvious choice of encoding is JSON. For example, we may have the following data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Action</span> <span class="ot">=</span> <span class="dt">Action</span> {<span class="ot"> actionType ::</span> <span class="dt">Text</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                     ,<span class="ot"> actionActor ::</span> <span class="dt">Text</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                     }</span></code></pre></div>
<p>Which has the following JSON encoding:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Action</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  toJSON <span class="dt">Action</span>{<span class="op">..</span>} <span class="ot">=</span> object [ <span class="st">&quot;type&quot;</span> <span class="op">.=</span> actionType</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                             , <span class="st">&quot;actor&quot;</span> <span class="op">.=</span> actionActor</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                             ]</span></code></pre></div>
<p>Now that we’ve done the easy part, we should make sure that we have sufficiently tested this encoding to ensure we are always using the <em>correct</em> encoding. QuickCheck would be a great tool for this: we simply generate <code>Arbitrary</code> <code>Action</code>s, and convert them to JSON, finally verifying that certain paths in the JSON encoding meet our expectations. Note it’s not enough to witness that <code>fromJSON . toJSON = id</code>, because that would only witness that <em>there exists</em> an isomorphism - but we need to be sure that we are using a <em>specific</em> encoding.</p>
<h2 id="a-first-attempt-at-testing">A First Attempt at Testing</h2>
<p>My first attempt looked something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testAction ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">TestTree</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>testAction <span class="ot">=</span> testGroup <span class="st">&quot;Action&quot;</span> [ testType, testActor ]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  testType <span class="ot">=</span> testProperty <span class="st">&quot;type&quot;</span> <span class="op">$</span> \action <span class="ot">-&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    toJSON action <span class="op">^?</span> key <span class="st">&quot;type&quot;</span> <span class="op">==</span> <span class="dt">Just</span> (actionType action)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  testActor <span class="ot">=</span> testProperty <span class="st">&quot;actor&quot;</span> <span class="op">$</span> \action <span class="ot">-&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    toJSON action <span class="op">^?</span> key <span class="st">&quot;actor&quot;</span> <span class="op">==</span> <span class="dt">Just</span> (actionActor action)</span></code></pre></div>
<p>(I’m using <code>lens-aeson</code> to traverse the AST that <code>aeson</code> produces).</p>
<p>This is a start, but it certainly looks a bit clunky. There’s a lot of repetition going on here - we have to repeat <code>toJSON action</code> and we have to make sure we access sub-parts of the input <code>action</code> correctly. Furthermore, when things go wrong - this doesn’t really explain <em>why</em> things have gone wrong - only that the property is not always satisfied, because our QuickCheck property only returns a boolean.</p>
<p>Nevertheless, in the spirit of getting the job done, we carry on.</p>
<p>The next data type I had to approach had a rather awkward encoding:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Sections</span> <span class="ot">=</span> <span class="dt">Sections</span> {<span class="ot"> sections ::</span> <span class="dt">Vector</span> <span class="dt">Section</span> }</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Section</span> <span class="ot">=</span> <span class="dt">Section</span> {<span class="ot"> sectionName ::</span> <span class="dt">Text</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> sectionUrl ::</span> <span class="dt">Text</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                       }</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Sections</span> <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">Sections</span> v) <span class="ot">=</span> object <span class="op">$</span> Vector.toList <span class="op">$</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> indices <span class="ot">=</span> Vector.enumFromN <span class="dv">0</span> (Vector.length v)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        encodeSection i <span class="dt">Section</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>          object</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            [ <span class="st">&quot;sections&quot;</span> <span class="op">.=</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                object [ sectionName <span class="op">.=</span> object</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                           [ <span class="st">&quot;sort-order&quot;</span> <span class="op">.=</span> i</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                           , <span class="st">&quot;url&quot;</span> <span class="op">.=</span> sectionUrl</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                           ]</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                       ]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> Vector.zipWith encodeSection indices v</span></code></pre></div>
<p>The encoding of a list of sections is an object from the section name to the section itself, but also containing the sort-order of this section inside the vector. QuickChecking this becomes a lot more involved - we would have to find the sections themselves, pull out the JSON for each section and keep a reference for that, then run tests against it - finally joining everything back together. Also, note that we have to test against arbitrary <code>Sections</code> - which means a single test is very big. Just having a boolean result is really not going to cut it now.</p>
<h2 id="declarative-tests">Declarative Tests</h2>
<p>The problem, at least to me, felt like I was explaining <em>how</em> to perform the testing, rather than <em>what</em> tests I needed to take. I would have rather said “for each section, expect a JSON object to exist under that key, and then expect these properties”. Armed with a description of the test, I would then be “free” to interpret these tests separately (get it? eh?). I’d heard a lot about free monads as a way to write DSLs recently, so this seemed like a perfect excuse to see just how much I understood them.</p>
<p>There appear to be three main tasks that we will perform in our JSON testing:</p>
<ul>
<li>Traversing into the value under a key of an object</li>
<li>Traversing into the value at an index in an array</li>
<li>Performed a test on the value we are currently looking at</li>
</ul>
<p>For the first two, movement in the JSON itself should correspond with a movement in the Haskell value we used to encode the JSON. For example, if I have an <code>Action</code> object above, traversing into the <code>"actionActor"</code> key should be matched by applying the <code>Action</code> we are encoding to the <code>actionActor</code> field accessor. Thus it seems like we can begin writing the functor that will make up our free monad:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">JSONF</span> a <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">String</span> (i <span class="ot">-&gt;</span> j) (j <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>But what a minute, where are these <code>i</code> and <code>j</code> type parameters coming from? We can think of <code>i</code> as being the initial value we are encoding, and <code>j</code> is a smaller part of <code>i</code> that resides under the key we are traversing into. There seems to be no reason to hide these, so we’ll introduce them as type parameters:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">JSONF</span> i j a <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">String</span> (i <span class="ot">-&gt;</span> j) (j <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>To recap, we have the name of the JSON key, an accessor function, and a continuation for the next step of the computation. This continuation receives the smaller structure we have traversed into (on the Haskell side).</p>
<p>A <code>Functor</code> instance here is easy enough:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">JSONF</span> i j) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Key</span> key accessor k) <span class="ot">=</span> <span class="dt">Key</span> key accessor (f <span class="op">.</span> k)</span></code></pre></div>
<p>Which means we are now ready to start experimenting with a free monad built from this functor. We introduce a smart constructor for layers in the free monad:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">key ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> j) <span class="ot">-&gt;</span> <span class="dt">Free</span> (<span class="dt">JSONF</span> i j) j</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>key k f <span class="ot">=</span> <span class="dt">Free</span> (<span class="dt">Key</span> k f <span class="dt">Pure</span>)</span></code></pre></div>
<p>And an interpreter:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">performTests ::</span> <span class="dt">ToJSON</span> i <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">JSONF</span> i j) a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>performTests f <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> encoded <span class="ot">=</span> toJSON subject</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">Pure</span> _) _ _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">Free</span> (<span class="dt">Key</span> keyName f k)) actual expected <span class="ot">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> actual <span class="op">^?</span> key keyName <span class="kw">of</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> subJSON <span class="ot">-&gt;</span> go (k <span class="op">$</span> f expected) subJSON (f expected)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span>      <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> go f encoded subject</span></code></pre></div>
<p>This so far gives us the ability to check the presence of keys in a JSON structure, but unfortunately we hit a snag. Lets say we have a <code>Sections</code> vector, and we just want to check the URL of one section:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testSections ::</span> <span class="op">??</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>testSections s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  key (sectionName <span class="op">$</span> Vector.head <span class="op">$</span> sections s)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      (Vector.head <span class="op">.</span> sections)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  key <span class="st">&quot;url&quot;</span> sectionUrl</span></code></pre></div>
<pre><code>    Couldn't match type `Section' with `Sections'
    Expected type: Free (JSONF Sections Section) Text
      Actual type: Free (JSONF Section Text) Text</code></pre>
<p>Bummer! The reason this doesn’t type check is a normal free monad builds on top of an un-indexed functor. Notice that the first accessor is from <code>Sections</code> to <code>Section</code>, while the second accessor is from <code>Section</code> to <code>Text</code>. Thus the functors are <code>JSONF Sections Section a</code> and <code>JSONF Section Text a</code>. These are not the same type of functor, thus we cannot use free monads to really do anything meaningful.</p>
<h2 id="indexed-free-monads">Indexed Free Monads</h2>
<p>Our <code>JSONF</code> is actually an <em>indexed</em> functor, because the different constructors permit us to change the index as we go. The index in this case is the state of the Haskell value before and after applying some sort of traversal into the JSON structure. Thankfully, it turns out the idea of an “indexed free monad” is perfectly natural, and Fumiaki Kinoshita and Edward Kmett have already done the hard work for us (thanks!).</p>
<p>The one draw back of this approach is that we can no longer use the <code>Monad</code> type class in the <code>Prelude</code>. If we use <code>-XRebindableSyntax</code> we can at least use <code>do</code> notation though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testSections ::</span> <span class="dt">IxFree</span> <span class="dt">JSONF</span> <span class="dt">Sections</span> <span class="dt">Text</span> <span class="dt">Text</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>testSections s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  key (sectionName <span class="op">$</span> Vector.head <span class="op">$</span> sections s)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      (Vector.head <span class="op">.</span> sections)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  key <span class="st">&quot;url&quot;</span> sectionUrl</span></code></pre></div>
<p>Alright! No changes to the implementation were necessary, just a change to the type signature. We’re on the right track. Now all that remains is to expand our vocabulary a bit more. Here’s a richer language for tests:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">JSONF</span> i j a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Key</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> j) <span class="ot">-&gt;</span> (j <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">JSON</span> i j a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Index</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> j) <span class="ot">-&gt;</span> (j <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">JSON</span> i j a</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Assert</span><span class="ot"> ::</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> ()) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">JSON</span> i i a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">key ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> j) <span class="ot">-&gt;</span> <span class="dt">JSONF</span> i j j</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>key key f <span class="ot">=</span> <span class="dt">Free</span> (<span class="dt">Key</span> key f <span class="dt">Pure</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">nth ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> j) <span class="ot">-&gt;</span> <span class="dt">JSONF</span> i j j</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>nth n f <span class="ot">=</span> <span class="dt">Free</span> (<span class="dt">Index</span> nth f <span class="dt">Pure</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assertEq ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">JSONF</span> i i ()</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>assertEq expected <span class="ot">=</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p actual</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> actual <span class="op">==</span> (toJSON expected) <span class="ot">=</span> <span class="dt">Right</span> ()</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">unlines</span> [ <span class="st">&quot;Expected: &quot;</span> <span class="op">++</span> <span class="fu">show</span> expected</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>                              , <span class="st">&quot;     Got: &quot;</span> <span class="op">++</span> <span class="fu">show</span> actual</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>                              ]</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="dt">Free</span> (<span class="dt">Assert</span> p (<span class="dt">Pure</span> ())</span></code></pre></div>
<p><code>Key</code> and <code>Index</code> move us deeper into the JSON structure, while <code>Assert</code> takes the current JSON <code>Value</code> and checks it against an arbitrary predicate. The predicate can fail with a string indicating why the assertion failed. I’ve added one smart constructor for predicates, which assumes that the current JSON matches the <code>ToJSON</code> encoding of a value. We can now rephrase the initial <code>Action</code> tests in our new DSL:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>testAction <span class="ot">=</span> testGroup <span class="st">&quot;Action&quot;</span> [ testType, testActor ]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  testType <span class="ot">=</span> testProperty <span class="st">&quot;type&quot;</span> <span class="op">$</span> performTests <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    actual <span class="ot">&lt;-</span> key <span class="st">&quot;type&quot;</span> actionType</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    assertEq actual</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  testActor <span class="ot">=</span> testProperty <span class="st">&quot;actor&quot;</span> <span class="op">$</span> performTests <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    actual <span class="ot">&lt;-</span> key <span class="st">&quot;actor&quot;</span> actionActor</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    assertEq actual</span></code></pre></div>
<p>Great - we’re at least as capable as before! It turns out we can go further, with just a little more work. If we upgrade to an indexed <code>MonadPlus</code> monad, we also gain the ability to perform multiple tests at once. This is the key part for testing arrays, as it permits us to backtrack our JSON traversal. This requires little work on our part - we simply switch out <code>Control.Monad.Indexed.Free.IxFree</code> for <code>Control.Monad.Indexed.Free.Plus.IxFree</code> and modify the interpreter to deal with the <code>Plus</code> constructor of <code>IxFree</code>. This would let us combine our two tests into one:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>testAction <span class="ot">=</span> testProperty <span class="st">&quot;Action&quot;</span> <span class="op">$</span> performTests <span class="op">$</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  isum [ key <span class="st">&quot;type&quot;</span> actionType   <span class="op">&gt;&gt;&gt;=</span> assertEq</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>       , key <span class="st">&quot;actor&quot;</span> actionActor <span class="op">&gt;&gt;&gt;=</span> assertEq</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>       ]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span><span class="ot"> isum ::</span> [<span class="dt">IxFree</span> i j a] <span class="ot">-&gt;</span> <span class="dt">IxFree</span> i j a</span></code></pre></div>
<p>I’ve also demonstrated here that now that we have used a monad as our underlying test representation, we get to make use of all the monadic combinators to structure our tests (or at least the indexed-monad equivalents).</p>
<h2 id="tell-me-whats-wrong">Tell Me What’s Wrong</h2>
<p>Now that our tests are more extensive, we really need to work on making it easy to respond to test failures. In order to do so, we need better diagnostics. Now that we have separate the test specification from the test running, it’s easy to add diagnostics - we just extend the test interpreter.</p>
<p>Each traversal - be it into an object by key or an array by index - is described in full in our functor. Thus when we interpret, we can also build up a human readable string of where we are, and say which properties fail to meet our expectations. The extended interpretor can be found <a href="https://github.com/ocharles/json-assertions/blob/master/src/Test/JSON/Assertions.hs">here</a> - I won’t go into details now, but hopefully you can follow it easily enough.</p>
<h2 id="yak-shaved.-now-back-to-the-problem">Yak: Shaved. Now Back to the Problem</h2>
<p>Finally, lets look at testing that horrible <code>Sections</code> vector that got us here in the first place. Our tests can now be expressed as:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testSections ::</span> <span class="dt">JSONTest</span> <span class="dt">Sections</span> </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>testSections <span class="ot">=</span> performTests <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  sections <span class="ot">&lt;-</span> key <span class="st">&quot;sections&quot;</span> sections</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  isum <span class="op">$</span> <span class="fu">flip</span> <span class="fu">map</span> [<span class="dv">0</span> <span class="op">..</span> Vector.length sections] <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="ot">=</span> sections <span class="op">Vector.!</span> sections</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    key (sectionName s) (<span class="fu">const</span> s)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    isum [ jsonTest <span class="op">$</span> key <span class="st">&quot;url&quot;</span> sectionUrl <span class="op">&gt;&gt;&gt;=</span> assertEq</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>         , jsonTest <span class="op">$</span> key <span class="st">&quot;sort-order&quot;</span> (<span class="fu">const</span> i) <span class="op">&gt;&gt;&gt;=</span> assertEq </span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>         ]</span></code></pre></div>
<p>We just need one more combinator - <code>jsonTest</code> - which simply discards the final state. The reason for this is because <code>isum</code> expects that all alternative actions end in the same state. We can easily end in the same state regardless of how we got there if we just always end with <code>()</code> - so <code>jsonTest :: JSONTest i j a -&gt; jsonTest i () a</code>.</p>
<p>I think this is a really concise way to explain the expectations of JSON serialisation for a fairly convoluted encoding. We move into the “sections” key, which is akin to pulling out the <code>Vector Section</code> from a <code>Sections</code>. Then, we access each element of this vector by its index (zipping each element with it’s index would also be appropriate), and for each <code>Section</code> we attempt to traverse into a key that matches the <code>sectionName</code>. I use <code>const s</code> as I already know the <code>Section</code> that I’m expecting. I complete my tests by summing a series of tests to be performed on this individual section. My tests can refer back to any previous variable that we bound earlier - so the test for the <code>"sort-order"</code> can elegantly refer back to the index of the <code>Section</code> in the original <code>sections</code> <code>Vector</code>.</p>
<h2 id="conclusion-and-next-steps">Conclusion and Next Steps</h2>
<p>I feel that I’ve mostly taken logical steps from the initial problem to <em>a</em> solution, but it’s not necessarily the only solution. The indexed monad felt natural due to the changing type of environment as I traverse the JSON. However, this comes with a cost for the user - as they now have to enable <code>RebindableSyntax</code> and bring appropriate definitions for <code>&gt;&gt;=</code> into scope. Is it possible that there are other types that we could use? I expect so! For example, things that move from <code>i</code> to <code>j</code> look suspiciously like arrows which we also get special notation in Haskell. Or maybe there’s a way to use existential types to hide the before or after types. I don’t know, but it may lead to yet simpler tests with less exotic structures underneath them.</p>
<p>Moving away from the underlying representation, this work could go further in terms of functionality too. So far it only tests that the JSON contains the right keys and values, but it doesn’t test <em>exhaustively</em>. It wouldn’t be much work to extend the interpreter to fail the test if there are unexpected keys too.</p>
<p>Either way, what I have at the moment feels useful enough to me that the real next step is to get this stuff onto Hackage. In the meantime, you can find this code on <a href="http://github.com/ocharles/json-assertions">my Github account</a>. I just have a few pull requests to get merged, and then I’ll release this.</p>
<hr />
<p style="font-style: italic">You can contact me via email
at <a href="mailto:ollie@ocharles.org.uk">ollie@ocharles.org.uk</a> or tweet to
me <a href="http://twitter.com/acid2">@acid2</a>. I share almost all of my work
at <a href="http://github.com/ocharles">GitHub</a>.
  This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">post</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.</p>
<hr />

    <ul id="icons">
      <li>
        <a href="https://coderwall.com/ocharles">
          <img alt="Endorse ocharles on Coderwall" src="http://api.coderwall.com/ocharles/endorsecount.png" style="width: auto" /></a></li>
      <li>
        <a href="http://twitter.com/acid2">Twitter
          <img src="../img/twitter.ico" /></a></li>
      <li>
        <a href="https://alpha.app.net/ocharles">App.net
          <img src="../img/adn.ico" /></a></li>
      <li>
        <a href="http://github.com/ocharles">GitHub
          <img src="../img/github.ico" /></a></li>
      <li>
        <a href="http://musicbrainz.org/user/acid2">MusicBrainz
          <img src="../img/musicbrainz.ico" /></a></li>
      <li>
        <a href="http://last.fm/user/acid2">Last.fm
          <img src="../img/lastfm.ico" /></a></li>
      <li>
        <a href="http://www.goodreads.com/user/show/8961303-oliver-charles">
          GoodReads <img src="../img/goodreads.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/bifurcations">
          SoundCloud (experimental) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/cycles">
          SoundCloud (older work) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="../posts.rss">RSS (posts)
          <img src="../img/rss.svg" /></a></li>
    </ul>
  </body>

<!-- Mirrored from blog.ocharles.org.uk/posts/2013-11-24-using-indexed-free-monads-to-quickcheck-json.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:59 GMT -->
</html>
