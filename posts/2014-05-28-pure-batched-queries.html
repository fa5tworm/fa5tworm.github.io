<!DOCTYPE html>
<html>
  
<!-- Mirrored from blog.ocharles.org.uk/posts/2014-05-28-pure-batched-queries.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:52 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>A Batch Querying Applicative Functor Without IORefs</title>
    <!-- <link rel="stylesheet" type="text/css" href="/css/reset.css" /> -->
    <!-- <link rel="stylesheet" type="text/css" href="/css/typography.css" /> -->
    <link rel="stylesheet" type="text/css" href="../css/syntax-highlighting.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../posts.rss">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,100" rel="stylesheet" type="text/css">
    <style>
    /*! Typebase.less v0.1.0 | MIT License */
    /* Setup */
    html {
      /* Change default typefaces here */
      font-size: 125%;
      -webkit-font-smoothing: antialiased;
      font-family: 'Roboto Slab', serif;
      font-weight: 300;
    }
    /* Copy & Lists */
    p, pre {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 0;
    }
    ul,
    ol {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    ul li,
    ol li {
      line-height: 1.5rem;
    }
    ul ul,
    ol ul,
    ul ol,
    ol ol {
      margin-top: 0;
      margin-bottom: 0;
    }
    blockquote {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* Headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      /* Change heading typefaces here */
      font-weight: 100;
      margin-top: 1.5rem;
      margin-bottom: 0;
      line-height: 1.5rem;
    }
    h1 {
      font-size: 3.242rem;
      line-height: 4.5rem;
      margin-top: 3rem;
      text-align: center;
      padding-bottom: 1.5rem;
    }
    h2 {
      font-size: 2.828rem;
      line-height: 3rem;
      margin-top: 3rem;
    }
    h3 {
      font-size: 1.414rem;
    }
    h4 {
      font-size: 0.707rem;
    }
    h5 {
      font-size: 0.4713333333333333rem;
    }
    h6 {
      font-size: 0.3535rem;
    }
    /* Tables */
    table {
      margin-top: 1.5rem;
      border-spacing: 0px;
      border-collapse: collapse;
    }
    table td,
    table th {
      padding: 0;
      line-height: 33px;
    }
    /* Leading paragraph text */
    .lead {
      font-size: 1.414rem;
    }
    /* Hug the block above you */
    .hug {
      margin-top: 0;
    }

    html {
      background: #eae3cb;
    }
    body {
      background-color: #fcf4dc;
      width: 40em;
      margin: 0 auto 2em;
      padding: 2em 3em;
      border: 1px solid #d9d2ba;
      border-top: none;
      color: #111;
    }
    h1 {
      border-bottom: 1px solid #555;
      /*text-align: center;
      padding-bottom: 10px;*/
    }
    /* h2,h3 { margin-top: 2em } */
    ul#icons {
      position: absolute;
      top: 10px;
      right: 10px;
      list-style-type: none;
      text-align: right;
    }
    ul#icons img { width: 16px; vertical-align: middle; }
    ul#icons a { color: transparent; font-style: italic; font-size: small; }
    ul#icons li:hover a { color: #aaa; text-decoration: none !important}
    #TOC { display: none; }
    pre {
      border-bottom: 1px dotted #d9d2ba;
      border-top: 1px dotted #d9d2ba;
    }
     a {
         text-decoration: none;
     }
    </style>
  </head>
  <body>
    <h1>A Batch Querying Applicative Functor Without IORefs</h1>
<p>Regular readers of my blog will remember that I recently blogged about a <a href="2014-03-24-queries-in-loops-without-a-care-in-the-world.html"><code>Querying</code> applicative functor</a>, which is able to “watch” for queries to a data store and batch multiple queries into one. It’s able to do all of this while allowing us to write code in a declarative manner, using traversals and other techniques we’re already familiar with. To refresh your memory, here’s an example what we can write with <code>Querying</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>withQuery getUsersById <span class="op">$</span> \usersById <span class="ot">-&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>withQuery getTagsByPostId <span class="op">$</span> \tagsByPostId <span class="ot">-&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  for blogPosts <span class="op">$</span> \post <span class="ot">-&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">BlogPost</span> <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> post</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*&gt;</span> usersById <span class="op">@?</span> postAuthor post</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;*&gt;</span> tagsByPostId <span class="op">@?</span> postId post</span></code></pre></div>
<p>In this example, we have a list of <code>blogPosts</code> that we want to load more information for. We loop over each post, and load the author and tags each post. Despite using a loop, by using <code>Querying</code> we only perform two queries, as <code>Querying</code> batches the queries together.</p>
<p>Even though we reached a viable solution, it left me unsatisfied. The solution relied on mutability (twice!) - once to record which keys were looked up (here we used an <code>IORef</code>), and again to create a suspended computation containing the result (an initially empty <code>MVar</code>). There’s no reason we should have to require mutability, so I’ve been searching for a pure solution - and I’m happy to say I’ve found it.</p>
<h2 id="one-at-a-time-please">One at a Time, Please</h2>
<p>To start understanding the problem, let’s look at a pure <code>Querying</code> applicative that works with a single query. A lot of people on Reddit immediately suggested this as an alternative solution to my <code>IORef</code> solution, but didn’t realise it only works for a single query. Nonetheless, it’s a good starting point:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Querying</span> k v a <span class="ot">=</span> <span class="dt">Querying</span> [k] ([(k, v)] <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>This applicative functor can be thought of as the product of two smaller applicative functors - the <code>Const [k]</code> functor collects a list of keys, and the <code>([(k, v)] -&gt;)</code> functor allows us to create a suspended computation awaiting results. If we write out the applicative instance by hand, we can see what it means to combine two <code>Querying</code>s together:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Querying</span> k v) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Querying</span> <span class="fu">mempty</span> (<span class="fu">pure</span> x)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Querying</span> ks f) <span class="op">&lt;*&gt;</span> (<span class="dt">Querying</span> ks' x) <span class="ot">=</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Querying</span> (ks <span class="op">&lt;&gt;</span> ks') (\result <span class="ot">-&gt;</span> f result <span class="op">&lt;*&gt;</span> x result)</span></code></pre></div>
<p>The pure computation asks no questions and thus doesn’t care what the results of the query are. We can combine two <code>Querying</code>s together by collecting the keys of both values, and creating a new computation suspend on the result that combine the underlying values.</p>
<p>The problem is that this applicative is now parameterized on a single key/value pair. If we have a <code>Querying Int String</code> and a <code>Querying Int Bool</code>, the two are different types and thus we can’t use <code>&lt;*&gt;</code> to combine them.</p>
<p>What we need to do is be able to store <em>lists</em> of key value pairs of potentially different types. If we could do this, then we can have a list of keys for every key value pair. Likewise, we want a similar construction for our suspended computation, one that would depend on the results of all queries. If we ask 3 queries, then we would like a function of three arguments.</p>
<h2 id="keylists">KeyLists</h2>
<p>First of all, let’s see how we can have a list of keys of different types. Since GHC learned how to promote data types to the type level, things have become a lot easier here. First, we’ll introduce a useful type of key value pairs - this will help us stay organised and principled at the type level:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">KV</span> k v <span class="ot">=</span> <span class="dt">KV</span> k v</span></code></pre></div>
<p>We won’t actually be constructing any terms of type <code>KV</code>, but we need a constructor to promote to be a type. Next, we introduce a GADT <code>KeyList</code> which is a list of lists of keys:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">KeyList</span><span class="ot"> ::</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">KeyList</span> '[]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> [k] <span class="ot">-&gt;</span> <span class="dt">KeyList</span> kvs <span class="ot">-&gt;</span> <span class="dt">KeyList</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs)</span></code></pre></div>
<p>The empty key list contains no information, and by constructing a term with <code>Nil</code>, we learn that there are no keys at all - as we can see by the empty list in the <em>type</em> of <code>Nil</code>. However, we also have a <code>Cons</code> constructor which takes a list of keys (of type <code>k</code>), and appends this list onto another list of potentially different types. So here we can see that we combine terms with cons, and we mirror this structure at the type level - we are consining a new <code>KV</code> <em>type</em> in the final type of <code>Cons</code>.</p>
<p>To emphasise the list-like nature of this data type, we can make it an instance of <code>Monoid</code>, which will be useful later. However, there are actually infinitely many monoid instances - one for every possible list of <code>KV</code>s. Fortunately, Haskell’s type classes are able to deal with this, by generating <code>Monoid</code> instances out of smaller ones:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">KeyList</span> '[]) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mappend</span> _ _ <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> (<span class="dt">KeyList</span> kvs)) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">KeyList</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs)) <span class="kw">where</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Cons</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mappend</span> (<span class="dt">Cons</span> l ls) (<span class="dt">Cons</span> r rs) <span class="ot">=</span> <span class="dt">Cons</span> (l <span class="op">++</span> r) (<span class="fu">mappend</span> ls rs)</span></code></pre></div>
<p>These monoid instances are somewhat reminiscent of an inductive proof - our base case is the empty list, and a monoid instance for a non-empty list relies on the monoid instance for a one-element-smaller list, which is a lot like making use of an inductive hypothesis.</p>
<h2 id="an-answer-for-every-question">An Answer For Every Question</h2>
<p>Now that we know that we can work with lists of keys of different types, we should next spend some time to work out how we’re going to create the suspended computation for multiple questions. Let’s look at a few examples to get a feel for things. For a single query, we want:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>[(k, v)] <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>For two queries, we want:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[(k1, v1)] <span class="ot">-&gt;</span> [(k, v)] <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Hmm, what about <em>zero</em> queries? Well, logically this would just be a term of type <code>a</code> - no function at all. Well hey, this again looks a lot like a list! We can use a very similar technique to building <code>KeyList</code> - but instead of storing lists, we would store functions. The constant value moves to be part of our base case:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ResultF</span><span class="ot"> ::</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ResultConst</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ResultF</span> '[] a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ResultFunc</span><span class="ot"> ::</span> ([(k, v)] <span class="ot">-&gt;</span> <span class="dt">ResultF</span> kvs a) <span class="ot">-&gt;</span> <span class="dt">ResultF</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs) a</span></code></pre></div>
<p>Because the base case carries a term, we need a way to mention the type of this term, so <code>ResultF kvs</code> actually constitutes a <code>Functor</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">ResultF</span> kvs) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">ResultConst</span> x) <span class="ot">=</span> <span class="dt">ResultConst</span> (f x)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">ResultFunc</span> g) <span class="ot">=</span> <span class="dt">ResultFunc</span> (<span class="fu">fmap</span> f <span class="op">.</span> g)</span></code></pre></div>
<p>This is a fairly natural definition - we just pattern match and either apply our function to the constant value, or we <code>fmap</code> inside the function, which builds up a new function.</p>
<p>In fact, <code>ResultF</code> actually creates a full applicative functor - a hint that we’re on the right track to building a larger applicative functor out of it. Applicative functors have the <code>pure</code> method as part of their type class, which is a producer of data. As such, we’ll have to make sure we have instances for any possible type of <code>ResultF</code>, as we did with our <code>KeyList</code> <code>Monoid</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">ResultF</span> '[]) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">ResultConst</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ResultConst</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">ResultConst</span> x) <span class="ot">=</span> <span class="dt">ResultConst</span> (f x)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">ResultF</span> kvs) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ResultF</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs)) <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">ResultFunc</span> (<span class="fu">const</span> (<span class="fu">pure</span> x))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ResultFunc</span> f) <span class="op">&lt;*&gt;</span> (<span class="dt">ResultFunc</span> x) <span class="ot">=</span> <span class="dt">ResultFunc</span> (\args <span class="ot">-&gt;</span> f args <span class="op">&lt;*&gt;</span> x args)</span></code></pre></div>
<p>These aren’t particularly pretty, but fortunately they aren’t particularly surprising either.</p>
<p>Believe it or not, we’re now ready to build our <code>Querying</code> functor!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Querying</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Querying</span><span class="ot"> ::</span> <span class="dt">KeyList</span> kvs <span class="ot">-&gt;</span> <span class="dt">Compose</span> m (<span class="dt">ResultF</span> kvs) a <span class="ot">-&gt;</span> <span class="dt">Querying</span> m kvs a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Querying</span> m kvs) <span class="kw">where</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Querying</span> kvs x) <span class="ot">=</span> <span class="dt">Querying</span> kvs (<span class="fu">fmap</span> f x)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Applicative</span> m, <span class="dt">Applicative</span> (<span class="dt">ResultF</span> kvs), <span class="dt">Monoid</span> (<span class="dt">KeyList</span> kvs)) <span class="ot">=&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Applicative</span> (<span class="dt">Querying</span> m kvs) <span class="kw">where</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Querying</span> <span class="fu">mempty</span> (<span class="fu">pure</span> a)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Querying</span> kvs f) <span class="op">&lt;*&gt;</span> (<span class="dt">Querying</span> kvs' x) <span class="ot">=</span> <span class="dt">Querying</span> (kvs <span class="op">&lt;&gt;</span> kvs') (f <span class="op">&lt;*&gt;</span> x)</span></code></pre></div>
<p><code>Querying</code> itself is just a combination of a key list and a monadic action producing a <code>ResultF</code> that eventually produces an <code>a</code> (I use <code>Compose</code> to help me write the <code>Applicative</code> instances). The <code>Functor</code> instance leaves the key list un-changed, and just uses the <code>Functor</code> instance for <code>ResultF</code> to do the heavy lifting.</p>
<p>The applicative instance may look a little bit more intricate, but look at the definitions… They are exactly the same as what we had before! This shouldn’t be surprising, but somehow… I can’t help but be surprised :)</p>
<h2 id="query-pointers">Query Pointers</h2>
<p>Now that we have the ability to build up <code>KeyList</code> and <code>ResultF</code> terms we’re making good progress. I have a loose plan - I want <code>withQuery</code> to introduce another level of scope in our <code>Querying</code> applicative. This corresponds to <code>Cons</code> for <code>KeyList</code> and adding a new <code>ResultFunc</code> layer for <code>ResultF</code>. Introducing a new level of scope will provide the user with a pointer to this scope, which gives them a way to demand results from the query.</p>
<p>But how do we represent these pointers? For usual lists, we can use natural numbers, but if we used numbers here we’d throw an awful lot of useful information away. A better description would be to describe the operations that someone has to do to the current scope to get to the data they seek. There are two possibilities: either the data you seek is at the outermost level of scope, or you have a pointer that is valid under that scope. You can think of this as “stripping away” one level of scoping and then carrying on a lookup. It may be easier to understand this by seeing the data type and some examples:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Where</span><span class="ot"> ::</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>] <span class="ot">-&gt;</span> (<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span><span class="ot"> ::</span> <span class="dt">Where</span> (kv '<span class="op">:</span> <span class="fu">tail</span>) kv</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">There</span><span class="ot"> ::</span> <span class="dt">Where</span> kvs kv <span class="ot">-&gt;</span> <span class="dt">Where</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs) kv</span></code></pre></div>
<p><code>Where</code> carries a list of scopes that it’s valid in as its first parameter, and its second parameter indicates exactly which key-value pair we’re pointing to. Either we’re pointing to the outermost scope with <code>Here</code>, or we want to strip off one layer of scope and then carry on.</p>
<p>For example, we could construct the following queries:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Here</span><span class="ot"> ::</span> <span class="ch">'['</span><span class="dt">KV</span> <span class="dt">Int</span> <span class="dt">Int</span>] (<span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">There</span> <span class="dt">Here</span><span class="ot"> ::</span> <span class="ch">'['</span><span class="dt">KV</span> <span class="dt">Int</span> <span class="dt">String</span>, <span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">Int</span>] (<span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">There</span> <span class="dt">Here</span><span class="ot"> ::</span> <span class="ch">'['</span><span class="dt">KV</span> <span class="dt">String</span> <span class="dt">Char</span>, <span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">String</span>, <span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">Int</span>] (<span class="dt">'KV</span> <span class="dt">Int</span> <span class="dt">String</span>)</span></code></pre></div>
<h2 id="introducing-queries">Introducing Queries</h2>
<p>The <code>Where</code> data type will provide us with a way to introduce a pointer to a query which is useful for <code>withQuery</code>. If I tease you with the type of <code>withQuery</code>, it will be easier to see what the plan is:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>withQuery</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> ([k] <span class="ot">-&gt;</span> m [(k, v)])</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="dt">Where</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs) (<span class="dt">'KV</span> k v) <span class="ot">-&gt;</span> <span class="dt">Querying</span> m (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs) a)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Querying</span> m kvs a</span></code></pre></div>
<p><code>withQuery</code> will take a query in some monad <code>m</code>, and a function to operate in a larger scope. We can see that we extend an existing <code>Querying</code> of <code>kvs</code> with a new level of scope for <code>KV k v</code>. The pointer that we pass in only has to reference the outermost scope, and we know that we can do that with <code>Here</code>. When we call the continuation with Here, we get back a <code>Querying</code> that contains some keys and a <code>ResultF</code>. <code>withQuery</code> then performs the query, and removes this outer scope to get us back to where we were:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>withQuery query k <span class="ot">=</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> k <span class="dt">Here</span> <span class="kw">of</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Querying</span> (keys <span class="ot">`Cons`</span> kvs) (<span class="dt">Compose</span> m) <span class="ot">-&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Querying</span> kvs <span class="op">$</span> <span class="dt">Compose</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">ResultFunc</span> f <span class="ot">&lt;-</span> m</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        results <span class="ot">&lt;-</span> query keys</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (f results)</span></code></pre></div>
<p>Once we have a query, how do we actually ask questions? A first approach might look like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> (<span class="dt">Eq</span> k, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Where</span> kvs (<span class="dt">'KV</span> k v) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Querying</span> m kvs (<span class="dt">Maybe</span> v)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ask q k <span class="ot">=</span> <span class="dt">Querying</span> (mkKeyList q k) (<span class="dt">Compose</span> <span class="op">$</span> <span class="fu">return</span> (mkResultF q k))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mkKeyList ::</span> <span class="dt">Where</span> kvs (<span class="dt">'KV</span> k v) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">KeyList</span> kvs</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>mkKeyList <span class="dt">Here</span> k <span class="ot">=</span> <span class="dt">Cons</span> [k] (<span class="fu">mempty</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>mkKeyList (<span class="dt">There</span> path) k <span class="ot">=</span> <span class="dt">Cons</span> [] (mkKeyList path k)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mkResultF ::</span> (<span class="dt">Eq</span> k) <span class="ot">=&gt;</span> <span class="dt">Where</span> kvs (<span class="dt">'KV</span> k v) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">ResultF</span> kvs (<span class="dt">Maybe</span> v)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>mkResultF <span class="dt">Here</span> k <span class="ot">=</span> <span class="dt">ResultFunc</span> (identityResultF <span class="op">.</span> <span class="fu">lookup</span> k)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>mkResultF (<span class="dt">There</span> path) k <span class="ot">=</span> <span class="dt">ResultFunc</span> (<span class="fu">const</span> (mkResultF path k))</span></code></pre></div>
<p>This is a reasonable amount of code, so lets walk through it. When we ask a query for the value under a specific key, we need to do two things. First we have to record that we are looking up a specific key, and secondly we have to create a suspended computation to lookup the result. Both of these are built by looking at the <code>Where</code> value for the query, which tells us how the index into the <code>KeyList</code> for keys for this query, and the corresponding position in the <code>ResultF</code> functor to extract the results.</p>
<p><code>mkKeyList</code> and <code>mkResultF</code> simply iterate on a <code>Where</code> value until they find <code>Here</code>. Once they do, they simply return a <code>KeyList</code> or <code>ResultF</code> from that point all the way to the bottom. For <code>KeyList</code> that’s easy - we use the <code>Monoid</code> instance to create empty cells for all subsequent nodes. For <code>ResultF</code> it’s a little more complex - but the idea is we simply ignore any subsequent parameters and just return our result. Check out the full code listing for a definition of <code>identityResultF</code>.</p>
<p>If we write a way to actually run a <code>Querying</code>, then what we have is already useful:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runQuerying ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Querying</span> m '[] a <span class="ot">-&gt;</span> m a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>runQuerying (<span class="dt">Querying</span> <span class="dt">Nil</span> (<span class="dt">Compose</span> m)) <span class="ot">=</span> liftM (\(<span class="dt">ResultConst</span> a) <span class="ot">-&gt;</span> a) m</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> [(<span class="dt">Maybe</span> <span class="dt">String</span>)]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  runQuerying <span class="op">$</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    withQuery getUserNameById <span class="op">$</span> \userNameById <span class="ot">-&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      for [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] <span class="op">$</span> \userId <span class="ot">-&gt;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        ask userNameById userId</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  getUserNameById ids <span class="ot">=</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> ids</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> [(<span class="dv">1</span>, <span class="st">&quot;Alice&quot;</span>), (<span class="dv">2</span>, <span class="st">&quot;Bob&quot;</span>)]</span></code></pre></div>
<pre><code>&gt; example &gt;&gt;= print</code></pre>
<p>Cool!</p>
<p>However, things fall apart pretty quickly if we try two queries at once:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> [(<span class="dt">Maybe</span> <span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">Int</span>)]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  runQuerying <span class="op">$</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    withQuery getUserNameById <span class="op">$</span> \userNameById <span class="ot">-&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    withQuery getUserAgeById <span class="op">$</span> \userAgeById <span class="ot">-&gt;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      for [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] <span class="op">$</span> \userId <span class="ot">-&gt;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        (,) <span class="op">&lt;$&gt;</span> ask userNameById userId</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;*&gt;</span> ask userAgeById userId</span></code></pre></div>
<pre><code></code></pre>
<p>So, what’s gone wrong? The problem is that when we call <code>withQuery</code> we are given a path into a <em>specific</em> list of key-values. However, <code>withQuery</code> modifies this very list. Thus if we open two queries, then the first query is no longer valid - because the second query is now operating in a larger environment. What we need to do is extend our old references to work with larger scopes. How would we do that?</p>
<p>When we extend the scope of a query, we grow the list of keys and the list of arguments in <code>ResultF</code> by one. Thus to make an existing query valid in this environment, we need to prepend <code>There</code> onto the query. Remember that <code>There</code> simply skips one layer - in this case stripping off a layer of scope and getting back to where we were.</p>
<p>It’s completely mechanical how many times we need to add <code>There</code>, and we want to exploit this and have GHC figure it out for us. This means we need to <em>infer</em> the amount of <code>There</code>s to add, and this is a perfect job for type classes. I’m going to add a new type class, <code>Somewhere</code>, which will take a <code>Where</code> term in one environment, and give you an equivalent path in a larger environment.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Somewhere</span> (<span class="ot">kvs ::</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>]) (<span class="ot">kvs' ::</span> [<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>]) (<span class="ot">kv ::</span> (<span class="dt">KV</span> <span class="op">*</span> <span class="op">*</span>)) <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  somewhere ::</span> <span class="dt">Where</span> kvs kv <span class="ot">-&gt;</span> <span class="dt">Where</span> kvs' kv</span></code></pre></div>
<p>All that’s left is to write the instances. The trivial case is that you are you trying to use a query in an environment where the query is already at the outer-most scope. In this case, the path is simply <code>Here</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Somewhere</span> (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs') (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs') (<span class="dt">'KV</span> k v) <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  somewhere _ <span class="ot">=</span> <span class="dt">Here</span></span></code></pre></div>
<p>Notice how we are referring to the same <code>k</code> and <code>v</code> at every place in the context for this type class instance.</p>
<p>The other scenario is that we have an environment that’s too big. In this case we use <code>There</code>, and try again with the smaller environment:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Somewhere</span> kvs kvs' kv <span class="ot">=&gt;</span> <span class="dt">Somewhere</span> kvs (<span class="dt">'KV</span> k v '<span class="op">:</span> kvs') kv <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  somewhere <span class="ot">=</span> <span class="dt">There</span> <span class="op">.</span> somewhere</span></code></pre></div>
<p>These instances overlap, so we’ll need <code>-XOverlappingInstances</code>, but it seems to be safe here.</p>
<p>Armed with this type class, we just need to modify <code>ask</code> to call <code>somewhere</code>, which now makes it more polymorphic in the environment type:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> (<span class="dt">Eq</span> k, <span class="dt">Monad</span> m, <span class="dt">Somewhere</span> kvs kvs' (<span class="dt">'KV</span> k v)) <span class="ot">=&gt;</span> <span class="dt">Where</span> kvs (<span class="dt">'KV</span> k v) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Querying</span> m kvs' (<span class="dt">Maybe</span> v)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>ask q k <span class="ot">=</span> <span class="dt">Querying</span> (mkKeyList (somewhere q) k) (<span class="dt">Compose</span> <span class="op">$</span> <span class="fu">return</span> (mkResultF (somewhere q) k))</span></code></pre></div>
<p>Again, notice that the query <code>kvs</code> is not necessarily the same as <code>Querying</code>’s <code>kvs'</code>. We require that the two environments are compatible though by <code>Somewhere</code> to the context of this function.</p>
<p>With this last change, we’re done - our example now compiles:</p>
<h2 id="concluding-thoughts">Concluding Thoughts</h2>
<p>When I first attempted to work on the batching <code>Querying</code> applicative functor, I felt like it could obviously be done with a pure solution. However, after a day of dead ends, I moved over to the <code>IORef</code> solution. However, as this post shows - the solution is very much possible and doesn’t require a particularly different formulation. What the solution does require is the ability to really understand how various different techniques (such as GADTs and type class) can be used, and how to retain information within the type system. The moment you lose information, problems of this nature become <em>very</em> complicated.</p>
<p>While I’ve provided a (hopefully!) coherent solution above, by no means was it as simple as I may have made out! Infact, this problem is a perfect case study of my favourite type of problems - the class of problems that are just <em>outside</em> my current capabilities. I highly encourage everyone to hold on to these problems - they don’t come up often, but the rewards if you follow it all the way to the solution are substantial. Don’t give up, but don’t be afraid to ask questions either.</p>
<hr />
<p style="font-style: italic">You can contact me via email
at <a href="mailto:ollie@ocharles.org.uk">ollie@ocharles.org.uk</a> or tweet to
me <a href="http://twitter.com/acid2">@acid2</a>. I share almost all of my work
at <a href="http://github.com/ocharles">GitHub</a>.
  This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">post</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.</p>
<hr />

    <ul id="icons">
      <li>
        <a href="https://coderwall.com/ocharles">
          <img alt="Endorse ocharles on Coderwall" src="http://api.coderwall.com/ocharles/endorsecount.png" style="width: auto" /></a></li>
      <li>
        <a href="http://twitter.com/acid2">Twitter
          <img src="../img/twitter.ico" /></a></li>
      <li>
        <a href="https://alpha.app.net/ocharles">App.net
          <img src="../img/adn.ico" /></a></li>
      <li>
        <a href="http://github.com/ocharles">GitHub
          <img src="../img/github.ico" /></a></li>
      <li>
        <a href="http://musicbrainz.org/user/acid2">MusicBrainz
          <img src="../img/musicbrainz.ico" /></a></li>
      <li>
        <a href="http://last.fm/user/acid2">Last.fm
          <img src="../img/lastfm.ico" /></a></li>
      <li>
        <a href="http://www.goodreads.com/user/show/8961303-oliver-charles">
          GoodReads <img src="../img/goodreads.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/bifurcations">
          SoundCloud (experimental) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/cycles">
          SoundCloud (older work) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="../posts.rss">RSS (posts)
          <img src="../img/rss.svg" /></a></li>
    </ul>
  </body>

<!-- Mirrored from blog.ocharles.org.uk/posts/2014-05-28-pure-batched-queries.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:52 GMT -->
</html>
