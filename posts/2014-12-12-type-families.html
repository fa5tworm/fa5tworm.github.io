<!DOCTYPE html>
<html>
  
<!-- Mirrored from blog.ocharles.org.uk/posts/2014-12-12-type-families.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:52 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>24 Days of GHC Extensions: Type Families</title>
    <!-- <link rel="stylesheet" type="text/css" href="/css/reset.css" /> -->
    <!-- <link rel="stylesheet" type="text/css" href="/css/typography.css" /> -->
    <link rel="stylesheet" type="text/css" href="../css/syntax-highlighting.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../posts.rss">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,100" rel="stylesheet" type="text/css">
    <style>
    /*! Typebase.less v0.1.0 | MIT License */
    /* Setup */
    html {
      /* Change default typefaces here */
      font-size: 125%;
      -webkit-font-smoothing: antialiased;
      font-family: 'Roboto Slab', serif;
      font-weight: 300;
    }
    /* Copy & Lists */
    p, pre {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 0;
    }
    ul,
    ol {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    ul li,
    ol li {
      line-height: 1.5rem;
    }
    ul ul,
    ol ul,
    ul ol,
    ol ol {
      margin-top: 0;
      margin-bottom: 0;
    }
    blockquote {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* Headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      /* Change heading typefaces here */
      font-weight: 100;
      margin-top: 1.5rem;
      margin-bottom: 0;
      line-height: 1.5rem;
    }
    h1 {
      font-size: 3.242rem;
      line-height: 4.5rem;
      margin-top: 3rem;
      text-align: center;
      padding-bottom: 1.5rem;
    }
    h2 {
      font-size: 2.828rem;
      line-height: 3rem;
      margin-top: 3rem;
    }
    h3 {
      font-size: 1.414rem;
    }
    h4 {
      font-size: 0.707rem;
    }
    h5 {
      font-size: 0.4713333333333333rem;
    }
    h6 {
      font-size: 0.3535rem;
    }
    /* Tables */
    table {
      margin-top: 1.5rem;
      border-spacing: 0px;
      border-collapse: collapse;
    }
    table td,
    table th {
      padding: 0;
      line-height: 33px;
    }
    /* Leading paragraph text */
    .lead {
      font-size: 1.414rem;
    }
    /* Hug the block above you */
    .hug {
      margin-top: 0;
    }

    html {
      background: #eae3cb;
    }
    body {
      background-color: #fcf4dc;
      width: 40em;
      margin: 0 auto 2em;
      padding: 2em 3em;
      border: 1px solid #d9d2ba;
      border-top: none;
      color: #111;
    }
    h1 {
      border-bottom: 1px solid #555;
      /*text-align: center;
      padding-bottom: 10px;*/
    }
    /* h2,h3 { margin-top: 2em } */
    ul#icons {
      position: absolute;
      top: 10px;
      right: 10px;
      list-style-type: none;
      text-align: right;
    }
    ul#icons img { width: 16px; vertical-align: middle; }
    ul#icons a { color: transparent; font-style: italic; font-size: small; }
    ul#icons li:hover a { color: #aaa; text-decoration: none !important}
    #TOC { display: none; }
    pre {
      border-bottom: 1px dotted #d9d2ba;
      border-top: 1px dotted #d9d2ba;
    }
     a {
         text-decoration: none;
     }
    </style>
  </head>
  <body>
    <h1>24 Days of GHC Extensions: Type Families</h1>
<p>Today, we’re going to look at an extension that radically alters the behavior of GHC Haskell by extending what we can do with types. The extension that we’re looking at is known as <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html">type families</a>, and it has a wide variety of applications.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.STM</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.MVar</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span></span></code></pre></div>
<p>As the extension is so large, we’re only going to touch the surface of the capabilities - though this extension is well documented, so there’s plenty of extra reading for those who are interested!</p>
<h2 id="associated-types">Associated Types</h2>
<p>To begin, lets look at the interaction of type families and type classes. In ordinary Haskell, a type class can associate a set of <em>methods</em> with a type. The type families extension will now allow us to associate <em>types</em> with a type.</p>
<p>As an example, lets try and abstract over the various mutable stores that we have available in Haskell. In the <code>IO</code> monad, we can use <code>IORef</code>s and <code>MVar</code>s to store data, whereas other monads have their own specific stores, as we’ll soon see. To begin with, we’ll start with a class over the different types of store:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IOStore</span> store <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  newIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (store a)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  getIO ::</span> store a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  putIO ::</span> store a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>This works fine for <code>IO</code> stores: we can add an instance for <code>MVar</code>…</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IOStore</span> <span class="dt">MVar</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  newIO <span class="ot">=</span> newMVar</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  getIO <span class="ot">=</span> readMVar</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  putIO mvar a <span class="ot">=</span> modifyMVar_ mvar (<span class="fu">return</span> <span class="op">.</span> <span class="fu">const</span> a)</span></code></pre></div>
<p>and an instance for <code>IORef</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IOStore</span> <span class="dt">IORef</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  newIO <span class="ot">=</span> newIORef</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  getIO <span class="ot">=</span> readIORef</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  putIO ioref a <span class="ot">=</span> modifyIORef ioref (<span class="fu">const</span> a)</span></code></pre></div>
<p>Now we have the ability to write functions that are polymorphic over stores:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Present</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">storePresentsIO ::</span> <span class="dt">IOStore</span> store <span class="ot">=&gt;</span> [<span class="dt">Present</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (store [<span class="dt">Present</span>])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>storePresentsIO xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  store <span class="ot">&lt;-</span> newIO []</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  forM_ xs <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    old <span class="ot">&lt;-</span> getIO store</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    putIO store (x <span class="op">:</span> old)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> store</span></code></pre></div>
<p>While this example is obviously contrived, hopefully you can see how we are able to interact with a memory store without choosing <em>which</em> store we are commiting to. We can use this by choosing the type we need, as the following GHCI session illustrates:</p>
<pre><code>.&gt; s &lt;- storePresentsIO [&quot;Category Theory Books&quot;] :: IO (IORef [Present])
.&gt; :t s
s :: IORef [Present]
.&gt; get s
[&quot;Category Theory Books&quot;]</code></pre>
<p>Cool - now we can go and extend this to <code>TVar</code> and other <code>STM</code> cells! Ack… there is a problem. Reviewing our <code>IOStore</code> type class, we can see that we’ve commited to working in the <code>IO</code> monad - and that’s a shame. What we’d like to be able to do is associate the type of monad with the type of store we’re using - as knowing the store tells us the monad that we have to work in.</p>
<p>To use type families, we use the <code>type</code> keyword within the <code>class</code> definition, and specify the <em>kind</em> of the type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Store</span> store <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">StoreMonad</span><span class="ot"> store ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  new ::</span> a <span class="ot">-&gt;</span> (<span class="dt">StoreMonad</span> store) (store a)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  get ::</span> store a <span class="ot">-&gt;</span> (<span class="dt">StoreMonad</span> store) a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  put ::</span> store a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">StoreMonad</span> store) ()</span></code></pre></div>
<p>As you can see, the types of the methods in the type class has become a little more complicated. Rather than working in the <code>IO</code> monad, we calculate the monad by using the <code>StoreMonad</code> type family.</p>
<p>The instances are similar to what we saw before, but we also have to provide the necessary type of monad:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Store</span> <span class="dt">IORef</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">StoreMonad</span> <span class="dt">IORef</span> <span class="ot">=</span> <span class="dt">IO</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  new <span class="ot">=</span> newIORef</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  get <span class="ot">=</span> readIORef</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  put ioref a <span class="ot">=</span> modifyIORef ioref (<span class="fu">const</span> a)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Store</span> <span class="dt">TVar</span> <span class="kw">where</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">StoreMonad</span> <span class="dt">TVar</span> <span class="ot">=</span> <span class="dt">STM</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  new <span class="ot">=</span> newTVar</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  get <span class="ot">=</span> readTVar</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  put ioref a <span class="ot">=</span> modifyTVar ioref (<span class="fu">const</span> a)</span></code></pre></div>
<p>As you can see - our methods don’t need to change at all; type families naturally extend the existing type class functionality. Our original <code>storePresentsIO</code> can now be made to work in any monad, with only a change to the type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">storePresents ::</span> (<span class="dt">Store</span> store, <span class="dt">Monad</span> (<span class="dt">StoreMonad</span> store))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> [<span class="dt">Present</span>] <span class="ot">-&gt;</span> (<span class="dt">StoreMonad</span> store) (store [<span class="dt">Present</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>storePresents xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  store <span class="ot">&lt;-</span> new []</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  forM_ xs <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    old <span class="ot">&lt;-</span> get store</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    put store (x <span class="op">:</span> old)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> store</span></code></pre></div>
<p>As we have an instance for <code>Store TVar</code>, we can now use this directly in an <code>STM</code> transaction:</p>
<pre><code>.&gt; atomically (do (storePresents [&quot;Distributed Computing Through Combinatorial Topology&quot;]
                     :: STM (TVar [Present])) &gt;&gt;= get)
[&quot;Distributed Computing Through Combinatorial Topology&quot;]</code></pre>
<p>Awesome!</p>
<h2 id="type-families-and-computation">Type Families and Computation</h2>
<p>What we’ve seen so far is extremely useful, but the fun needn’t stop there! Type families also give us the ability to compute over types! Traditionally, Haskell is built around value level computation - running programs should do something. That said, we all know how useful it is to have functions - so why can’t we have them at the type level? Well, now that we have the ability to associate types with types, we can!</p>
<p>To look at this new functionality (closed type families), we need a few more extensions to really unlock the potential here, so I’ll finish this blog post on that cliff hanger. Watch this space!</p>
<hr />
<p><em>This post is part of <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a> - for more posts like this, check out the <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">calendar</a></em>.</p>
<hr />
<p style="font-style: italic">You can contact me via email
at <a href="mailto:ollie@ocharles.org.uk">ollie@ocharles.org.uk</a> or tweet to
me <a href="http://twitter.com/acid2">@acid2</a>. I share almost all of my work
at <a href="http://github.com/ocharles">GitHub</a>.
  This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">post</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.</p>
<hr />

    <ul id="icons">
      <li>
        <a href="https://coderwall.com/ocharles">
          <img alt="Endorse ocharles on Coderwall" src="http://api.coderwall.com/ocharles/endorsecount.png" style="width: auto" /></a></li>
      <li>
        <a href="http://twitter.com/acid2">Twitter
          <img src="../img/twitter.ico" /></a></li>
      <li>
        <a href="https://alpha.app.net/ocharles">App.net
          <img src="../img/adn.ico" /></a></li>
      <li>
        <a href="http://github.com/ocharles">GitHub
          <img src="../img/github.ico" /></a></li>
      <li>
        <a href="http://musicbrainz.org/user/acid2">MusicBrainz
          <img src="../img/musicbrainz.ico" /></a></li>
      <li>
        <a href="http://last.fm/user/acid2">Last.fm
          <img src="../img/lastfm.ico" /></a></li>
      <li>
        <a href="http://www.goodreads.com/user/show/8961303-oliver-charles">
          GoodReads <img src="../img/goodreads.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/bifurcations">
          SoundCloud (experimental) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/cycles">
          SoundCloud (older work) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="../posts.rss">RSS (posts)
          <img src="../img/rss.svg" /></a></li>
    </ul>
  </body>

<!-- Mirrored from blog.ocharles.org.uk/posts/2014-12-12-type-families.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:52 GMT -->
</html>
