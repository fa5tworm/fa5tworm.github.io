<!DOCTYPE html>
<html>
  
<!-- Mirrored from blog.ocharles.org.uk/posts/2017-08-23-extensible-effects-and-transformers.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:51 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Providing an API for extensible-effects and monad transformers</title>
    <!-- <link rel="stylesheet" type="text/css" href="/css/reset.css" /> -->
    <!-- <link rel="stylesheet" type="text/css" href="/css/typography.css" /> -->
    <link rel="stylesheet" type="text/css" href="../css/syntax-highlighting.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../posts.rss">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,100" rel="stylesheet" type="text/css">
    <style>
    /*! Typebase.less v0.1.0 | MIT License */
    /* Setup */
    html {
      /* Change default typefaces here */
      font-size: 125%;
      -webkit-font-smoothing: antialiased;
      font-family: 'Roboto Slab', serif;
      font-weight: 300;
    }
    /* Copy & Lists */
    p, pre {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 0;
    }
    ul,
    ol {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    ul li,
    ol li {
      line-height: 1.5rem;
    }
    ul ul,
    ol ul,
    ul ol,
    ol ol {
      margin-top: 0;
      margin-bottom: 0;
    }
    blockquote {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* Headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      /* Change heading typefaces here */
      font-weight: 100;
      margin-top: 1.5rem;
      margin-bottom: 0;
      line-height: 1.5rem;
    }
    h1 {
      font-size: 3.242rem;
      line-height: 4.5rem;
      margin-top: 3rem;
      text-align: center;
      padding-bottom: 1.5rem;
    }
    h2 {
      font-size: 2.828rem;
      line-height: 3rem;
      margin-top: 3rem;
    }
    h3 {
      font-size: 1.414rem;
    }
    h4 {
      font-size: 0.707rem;
    }
    h5 {
      font-size: 0.4713333333333333rem;
    }
    h6 {
      font-size: 0.3535rem;
    }
    /* Tables */
    table {
      margin-top: 1.5rem;
      border-spacing: 0px;
      border-collapse: collapse;
    }
    table td,
    table th {
      padding: 0;
      line-height: 33px;
    }
    /* Leading paragraph text */
    .lead {
      font-size: 1.414rem;
    }
    /* Hug the block above you */
    .hug {
      margin-top: 0;
    }

    html {
      background: #eae3cb;
    }
    body {
      background-color: #fcf4dc;
      width: 40em;
      margin: 0 auto 2em;
      padding: 2em 3em;
      border: 1px solid #d9d2ba;
      border-top: none;
      color: #111;
    }
    h1 {
      border-bottom: 1px solid #555;
      /*text-align: center;
      padding-bottom: 10px;*/
    }
    /* h2,h3 { margin-top: 2em } */
    ul#icons {
      position: absolute;
      top: 10px;
      right: 10px;
      list-style-type: none;
      text-align: right;
    }
    ul#icons img { width: 16px; vertical-align: middle; }
    ul#icons a { color: transparent; font-style: italic; font-size: small; }
    ul#icons li:hover a { color: #aaa; text-decoration: none !important}
    #TOC { display: none; }
    pre {
      border-bottom: 1px dotted #d9d2ba;
      border-top: 1px dotted #d9d2ba;
    }
     a {
         text-decoration: none;
     }
    </style>
  </head>
  <body>
    <h1>Providing an API for extensible-effects and monad transformers</h1>
<p>I was recently working on a small little project - a client API for the <a href="https://listenbrainz.org/">ListenBrainz</a> project. Most of the details aren’t particularly interesting - it’s just a HTTP client library to a REST-like API with JSON. For the implementation, I let Servant and aeson do most of the heavy lifting, but I got stuck when considering what final API to give to <em>my</em> users.</p>
<p>Obviously, interacting with ListenBrainz requires some sort of IO so whatever API I will be offering has to live within some sort of monad. Currently, there are three major options:</p>
<ol type="1">
<li><p><em>Supply an API targetting a concrete monad stack.</em></p>
<p>Under this option, our API would have types such as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">submitListens ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">M</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getListens ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Listens</span></span></code></pre></div>
<p>where <code>M</code> is some <em>particular</em> monad (or monad transformer).</p></li>
<li><p><em>Supply an API using type classes</em></p>
<p>This is the <code>mtl</code> approach. Rather than choosing which monad my users have to work in, my API can be polymorphic over monads that support accessing the ListenBrainz API. This means my API is more like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">submitListens ::</span> <span class="dt">MonadListenBrainz</span> m <span class="ot">=&gt;</span> <span class="op">...</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getListens ::</span> <span class="dt">MonadListenBrainz</span> m <span class="ot">=&gt;</span> <span class="op">...</span> <span class="ot">-&gt;</span> m <span class="dt">Listens</span></span></code></pre></div></li>
<li><p><em>Use an extensible effects framework.</em></p>
<p>Extensible effects are a fairly new entry, that are something of a mix of the above options. We target a family of concrete monads - <code>Eff</code> - but the extensible effects framework lets our effect (querying ListenBrainz) seamlessly compose with other effects. Using <code>freer-effects</code>, our API would be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">submitListens ::</span> <span class="dt">Member</span> <span class="dt">ListenBrainzAPICall</span> effects <span class="ot">=&gt;</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effects ()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getListens ::</span> <span class="dt">Member</span> <span class="dt">ListenBrainzAPICall</span> effects <span class="ot">=&gt;</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> effects <span class="dt">Listens</span></span></code></pre></div></li>
</ol>
<p>So, which do we choose? Evaluating the options, I have some concerns.</p>
<p>For option one, we impose pain on all our users who want to use a different monad stack. It’s unlikely that your application is going to be written solely to query ListenBrainz, which means client code becomes littered with <code>lift</code>. You may write that off as syntactic, but there is another problem - we have committed to an interpretation strategy. Rather than describing API calls, my library now skips directly to prescribing how to run API calls. However, it’s entirely possible that you want to intercept these calls - maybe introducing a caching layer or additional logging. Your only option is to duplicate my API into your own project and wrap each function call and then change your program to use your API rather than mine. Essentially, the program itself is no longer a first class value that you can transform.</p>
<p>Extensible effects gives us a solution to both of the above. The use of the <code>Member</code> type class automatically reshuffles effects so that multiple effects can be combined without syntatic overhead, and we only commit to an interpretation strategy when we actually run the program. <code>Eff</code> is essentially a <em>free monad</em>, which captures the syntax tree of effects, rather than the result of their execution.</p>
<p>Sounds good, but extensible effects come with (at least) two problems that make me hesistant: they are experimental and esoteric, and it’s unclear that they are performant. By using <em>only</em> extensible effects, I am forcing an extensible effects framework on my users, and I’d rather not dictate that. Of course, extensible effects can be composed with traditional monad transformers, but I’ve still imposed an unnecessary burden on my users.</p>
<p>So, what do we do? Well, as Old El Paso has taught us: why don’t we have both?</p>
<p>It’s trivial to actually support both a monad transformer stack <em>and</em> extensible effects by using an <code>mtl</code> type class. As I argue in <a href="2016-01-26-transformers-free-monads-mtl-laws.html">Monad transformers, free monads, mtl, laws and a new approach</a>, I think the best pattern for an <code>mtl</code> class is to be a monad homomorphism from a program description, and often a free monad is a fine choice to lift:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadListenBrainz</span> m <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  liftListenBrainz ::</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>But what about <code>f</code>? As observed earlier, extensible effects are basically free monads, so we can actually share the same implementation. For <code>freer-effects</code>, we might describe the ListenBrainz API with a GADT such as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListenBrainzAPICall</span> returns <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetListens</span><span class="ot"> ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">ListenBrainzAPICall</span> <span class="dt">Listens</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SubmitListens</span><span class="ot"> ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> <span class="dt">ListenBrainzAPICall</span> ()</span></code></pre></div>
<p>However, this isn’t a functor - it’s just a normal data type. In order for <code>Free f a</code> to actually be a monad, we need <code>f</code> to be a functor. We could rewrite <code>ListenBrainzAPICall</code> into a functor, but it’s even easier to just fabricate a functor for free - and that’s exactly <a href="https://www.reddit.com/r/haskelltil/comments/4ea7er/coyoneda_is_just_the_free_functor/">what <code>Coyoneda</code> will do</a>. Thus our <code>mtl</code> type class becomes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadListenBrainz</span> m <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  liftListenBrainz ::</span> <span class="dt">Free</span> (<span class="dt">Coyoneda</span> <span class="dt">ListenBrainzAPICall</span>) a <span class="ot">-&gt;</span> m a </span></code></pre></div>
<p>We can now provide an implementation in terms of a monad transformer:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadListenBrainz</span> (<span class="dt">ListenBrainzT</span> m)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  liftListenBrainz f <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    iterM (join <span class="op">.</span> lowerCoyoneda <span class="op">.</span> hoistCoyoneda go)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">      go ::</span> <span class="dt">ListenBrainzAPICall</span> a <span class="ot">-&gt;</span> <span class="dt">ListenBrainzT</span> m a</span></code></pre></div>
<p>or extensible effects:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Member</span> <span class="dt">ListenBrainzAPICall</span> effs <span class="ot">=&gt;</span> <span class="dt">MonadListenBrainz</span> (<span class="dt">Eff</span> effs) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  liftListenBrainz f <span class="ot">=</span> iterM (join <span class="op">.</span> lowerCoyoneda <span class="op">.</span> hoistCoyoneda send) f </span></code></pre></div>
<p>or maybe directly to a free monad for later inspection:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadListenBrainz</span> (<span class="dt">Free</span> (<span class="dt">Coyoneda</span> <span class="dt">ListenBrainzAPICall</span>)) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  liftListenBrainz <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>For the actual implementation of performing the API call, I work with a concrete monad transformer stack:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">performAPICall ::</span> <span class="dt">Manager</span> <span class="ot">-&gt;</span> <span class="dt">ListenBrainzAPICall</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ServantError</span> a)</span></code></pre></div>
<p>which both my extensible effects “run” function calls, or the <code>go</code> function in the <code>iterM</code> call for <code>ListenBrainzT</code>’s <code>MonadListenBrainz</code> instance.</p>
<p>In conclusion, I’m able to offer my users a choice of either:</p>
<ul>
<li>a traditional monad transformer approach, which doesn’t commit to a particular intepretation strategy by using an <code>mtl</code> type class</li>
<li>extensible effects</li>
</ul>
<p>All without extra syntatic burden, a complicated type class, or duplicating the implementation.</p>
<p>You can see the final implementation of <a href="https://hackage.haskell.org/package/listenbrainz-client-1.0.1/docs/src/Web-ListenBrainz.html"><code>listenbrainz-client</code> here</a>.</p>
<h3 id="bonus---what-about-the-readert-pattern">Bonus - what about the ReaderT pattern?</h3>
<p>The <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">ReaderT design pattern</a> has been mentioned recently, so where does this fit in? There are two options if we wanted to follow this pattern:</p>
<ul>
<li>We require a HTTP <code>Manager</code> in our environment, and commit to using this. This has all the problems of providing a concrete monad transformer stack - we are committing to an interpretation.</li>
<li>We require a family of functions that explain how to perform each API call. This kind of like a <a href="http://r6.ca/blog/20140210T181244Z.html">van Laarhoven free monad</a>, or really just explicit dictionary passing. I don’t see this really gaining much on abstracting with type classes.</li>
</ul>
<p>I don’t feel like the ReaderT design pattern offers anything that isn’t already dealt with above.</p>
<hr />
<p style="font-style: italic">You can contact me via email
at <a href="mailto:ollie@ocharles.org.uk">ollie@ocharles.org.uk</a> or tweet to
me <a href="http://twitter.com/acid2">@acid2</a>. I share almost all of my work
at <a href="http://github.com/ocharles">GitHub</a>.
  This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">post</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.</p>
<hr />

    <ul id="icons">
      <li>
        <a href="https://coderwall.com/ocharles">
          <img alt="Endorse ocharles on Coderwall" src="http://api.coderwall.com/ocharles/endorsecount.png" style="width: auto" /></a></li>
      <li>
        <a href="http://twitter.com/acid2">Twitter
          <img src="../img/twitter.ico" /></a></li>
      <li>
        <a href="https://alpha.app.net/ocharles">App.net
          <img src="../img/adn.ico" /></a></li>
      <li>
        <a href="http://github.com/ocharles">GitHub
          <img src="../img/github.ico" /></a></li>
      <li>
        <a href="http://musicbrainz.org/user/acid2">MusicBrainz
          <img src="../img/musicbrainz.ico" /></a></li>
      <li>
        <a href="http://last.fm/user/acid2">Last.fm
          <img src="../img/lastfm.ico" /></a></li>
      <li>
        <a href="http://www.goodreads.com/user/show/8961303-oliver-charles">
          GoodReads <img src="../img/goodreads.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/bifurcations">
          SoundCloud (experimental) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="http://www.soundcloud.com/cycles">
          SoundCloud (older work) <img src="../img/soundcloud.ico" /></a></li>
      <li>
        <a href="../posts.rss">RSS (posts)
          <img src="../img/rss.svg" /></a></li>
    </ul>
  </body>

<!-- Mirrored from blog.ocharles.org.uk/posts/2017-08-23-extensible-effects-and-transformers.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Aug 2024 22:56:51 GMT -->
</html>
