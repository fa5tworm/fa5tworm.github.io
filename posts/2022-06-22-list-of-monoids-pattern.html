<!DOCTYPE html>
<html>
  
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>The list of monoids pattern</title>
    <!-- <link rel="stylesheet" type="text/css" href="/css/reset.css" /> -->
    <!-- <link rel="stylesheet" type="text/css" href="/css/typography.css" /> -->
    <link rel="stylesheet" type="text/css" href="../css/syntax-highlighting.css" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../posts.rss">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:300,100" rel="stylesheet" type="text/css">
    <style>
    /*! Typebase.less v0.1.0 | MIT License */
    /* Setup */
    html {
      /* Change default typefaces here */
      font-size: 125%;
      -webkit-font-smoothing: antialiased;
      font-family: 'Roboto Slab', serif;
      font-weight: 300;
    }
    /* Copy & Lists */
    p, pre {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 0;
    }
    ul,
    ol {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    ul li,
    ol li {
      line-height: 1.5rem;
    }
    ul ul,
    ol ul,
    ul ol,
    ol ol {
      margin-top: 0;
      margin-bottom: 0;
    }
    blockquote {
      line-height: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* Headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      /* Change heading typefaces here */
      font-weight: 100;
      margin-top: 1.5rem;
      margin-bottom: 0;
      line-height: 1.5rem;
    }
    h1 {
      font-size: 3.242rem;
      line-height: 4.5rem;
      margin-top: 3rem;
      text-align: center;
      padding-bottom: 1.5rem;
    }
    h2 {
      font-size: 2.828rem;
      line-height: 3rem;
      margin-top: 3rem;
    }
    h3 {
      font-size: 1.414rem;
    }
    h4 {
      font-size: 0.707rem;
    }
    h5 {
      font-size: 0.4713333333333333rem;
    }
    h6 {
      font-size: 0.3535rem;
    }
    /* Tables */
    table {
      margin-top: 1.5rem;
      border-spacing: 0px;
      border-collapse: collapse;
    }
    table td,
    table th {
      padding: 0;
      line-height: 33px;
    }
    /* Leading paragraph text */
    .lead {
      font-size: 1.414rem;
    }
    /* Hug the block above you */
    .hug {
      margin-top: 0;
    }

    html {
      background: #eae3cb;
    }
    body {
      background-color: #fcf4dc;
      width: 40em;
      margin: 0 auto 2em;
      padding: 2em 3em;
      border: 1px solid #d9d2ba;
      border-top: none;
      color: #111;
    }
    h1 {
      border-bottom: 1px solid #555;
      /*text-align: center;
      padding-bottom: 10px;*/
    }
    /* h2,h3 { margin-top: 2em } */
    ul#icons {
      position: absolute;
      top: 10px;
      right: 10px;
      list-style-type: none;
      text-align: right;
    }
    ul#icons img { width: 16px; vertical-align: middle; }
    ul#icons a { color: transparent; font-style: italic; font-size: small; }
    ul#icons li:hover a { color: #aaa; text-decoration: none !important}
    #TOC { display: none; }
    pre {
      border-bottom: 1px dotted #d9d2ba;
      border-top: 1px dotted #d9d2ba;
    }
     a {
         text-decoration: none;
     }
    </style>
  </head>
  <body>
    <h1>The list of monoids pattern</h1>
<p>Hello! Yes, this blog is still alive. In this post, I want to share a small little pattern that I’ve found to have a surprisingly high quality-of-life improvement, and I call it the <em>list of monoids</em> pattern.</p>
<p>The idea is that whenever we have a monoidal value - a type that is an instance of the <code>Monoid</code> type class - we can sometimes produce a more ergonomic API if we change our functions to instead to a list of these monoidal values.</p>
<p>I recently <a href="https://github.com/chrisdone/lucid/issues/127">proposed an instance of this pattern to <code>lucid</code></a>, and it was well received and ultimately merged as part of the new <a href="https://hackage.haskell.org/package/lucid2-0.0.20220526"><code>lucid2</code></a> package. To motivate this post, I’m going to start by reiterating my proposal.</p>
<p><code>lucid</code> is a domain specific language for producing HTML documents. In <code>lucid</code> we have the <a href="https://hackage.haskell.org/package/lucid-2.11.1/docs/Lucid-Base.html#t:Attribute"><code>Attribute</code></a> type which represents a single key-value pairing. When we construct HTML elements, we supply a <code>[Attribute]</code> list. For example,</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">div_ ::</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span> a <span class="ot">-&gt;</span> <span class="dt">Html</span> a</span></code></pre></div>
<p>(Note that <code>lucid</code> has an overloading mechanism, and this is one possible type of <code>div_</code>).</p>
<p>The problem with this API is that it makes it difficult to abstract groups of attributes and reuse them.</p>
<h2 id="example-1">Example 1</h2>
<p>My motivation came from using the fantastic <a href="https://htmx.org/">HTMX</a> library, and wanting to group a common set of attributes that are needed whenever you connect an element with an end-point that serves <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">server-sent events</a>. More specifically, I wanted to “tail” an event stream, automatically scrolling the latest element of the stream into view (using <a href="https://alpinejs.dev/">Alpine.js</a>). An example of the attributes are:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;div</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   hx-sse=</span><span class="st">&quot;connect:/stream&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   hx-swap=</span><span class="st">&quot;beforeend&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">   x-on:sse-message.camel=</span><span class="st">&quot;$el.scrollIntoView(false);&quot;</span><span class="kw">&gt;</span></span></code></pre></div>
<p>In <code>lucid</code>, we can express this as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>div_</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  [ makeAttribute &quot;hx-sse&quot; &quot;connect:/stream&quot;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  , makeAttribute &quot;hx-swap&quot; &quot;beforeend&quot;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  , makeAttribute &quot;x-on:sse-message.camel&quot; &quot;$el.scrollIntoView(false);&quot;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>This is great, but my problem is wanting to re-use these attributes. If I have another page that I also want to have a stream in, I could copy these attributes, but the programmer in me is unhappy with that. Instead, I want to try and share this definition.</p>
<p>One option is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>tailSSE url <span class="ot">=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  [ makeAttribute <span class="st">&quot;hx-sse&quot;</span> <span class="op">$</span> <span class="st">&quot;connect:&quot;</span> <span class="op">&lt;&gt;</span> url</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  , makeAttribute <span class="st">&quot;hx-swap&quot;</span> <span class="st">&quot;beforeend&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  , makeAttribute <span class="st">&quot;x-on:sse-message.camel&quot;</span> <span class="st">&quot;$el.scrollIntoView(false);&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>But look what happens when I use this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>div_</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">concat</span> [ tailSSE <span class="st">&quot;/stream&quot;</span>, [ class_ <span class="st">&quot;stream-container&quot;</span> ] ])</span></code></pre></div>
<p>Urgh! Just using this requires that I call <code>concat</code>, and to use more attributes I have to nest them in another list, and then I have to surround the whole thing in parenthesis. Worse, look what happens if we consider this code in the context of more “ordinary” HTML:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>div_ [class_ <span class="st">&quot;page&quot;</span>] <span class="kw">do</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  h1_ <span class="st">&quot;Heading&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  div_</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    [class_ <span class="st">&quot;scroll&quot;</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      div_</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        ( <span class="fu">concat</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            [ tailSSE <span class="st">&quot;/stream&quot;</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>              [ class_ <span class="st">&quot;stream-container&quot;</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                id_ <span class="st">&quot;stream-1&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>              ]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<p>Our SSE attributes stand out like a sore thumb, ruining the nice DSL that <code>lucid</code> gives us.</p>
<p>At this point, we need to start thinking about ways to fix this.</p>
<p>Before we get to that, let’s look at one more example</p>
<h2 id="example-2">Example 2</h2>
<p>Continuing with <code>lucid</code>, I’m also a user of <a href="https://tailwindcss.com/">Tailwind</a> for styling pages. In Tailwind, we combine primitive classes to style our elements. Sometimes, this styling needs to be conditional. When we we layout a list, we might want to emphasize a particular element:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ul_ <span class="kw">do</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  li_ [ class_ <span class="st">&quot;p-4&quot;</span> ] <span class="st">&quot;Item 1&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  li_ [ class_ <span class="st">&quot;p-4 font-bold&quot;</span> ] <span class="st">&quot;Item 2&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  li_ [ class_ <span class="st">&quot;p-4&quot;</span> ] <span class="st">&quot;Item 3&quot;</span></span></code></pre></div>
<p>Generally this list will come from another container which we want to enumerate over:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ul_ <span class="kw">do</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  for_ items \item <span class="ot">-&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    li_ [ class_ <span class="op">$</span> <span class="kw">if</span> active item <span class="kw">then</span> <span class="st">&quot;p-4 font-bold&quot;</span> <span class="kw">else</span> <span class="st">&quot;p-4&quot;</span> ]</span></code></pre></div>
<p>It’s unfortunate that we’ve had to repeat <code>p-4</code> here. We could of course factor that out, but what I more generally want to do is define a common attribute for list items, and another attribute that indicates active. Then, for active items I can just conditionally add the “active” element:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ul_ <span class="kw">do</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  for_ items \item <span class="ot">-&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    li_</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      [ class_ <span class="st">&quot;p-4&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      , <span class="kw">if</span> active item <span class="kw">then</span> class_ <span class="st">&quot;font-bold&quot;</span> <span class="kw">else</span> <span class="op">???</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      (toHTML (caption item))</span></code></pre></div>
<p>But what we are we going to put for <code>???</code>? There isn’t really an “identity” attribute. A common hack is to add <code>class_ ""</code>, but that is definitely a hack.</p>
<h2 id="solutions">Solutions</h2>
<p>If you see both of these problems, a natural reaction might be to make <code>Attribute</code> an instance of <code>Monoid</code>. We might change the type of</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">div_ ::</span> <span class="dt">Attributes</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> a <span class="ot">-&gt;</span> <span class="dt">Html</span> a</span></code></pre></div>
<p>However, when we do this we momentarily make things a little worse. Starting with the second example 2:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ul_ <span class="kw">do</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  for_ items \item <span class="ot">-&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    li_</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      ( <span class="fu">mconcat</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          [ class_ <span class="st">&quot;p-4&quot;</span>,</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          , <span class="kw">if</span> active item <span class="kw">then</span> class_ <span class="st">&quot;font-bold&quot;</span> <span class="kw">else</span> <span class="fu">mempty</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>          ]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      (toHTML (caption item))</span></code></pre></div>
<p>Our <code>???</code> becomes <code>mempty</code> which literally means “no attributes at all”. This solves our problem, but the cost is that overall the API has got more verbose.</p>
<p>How about our first example?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>div_ (class_ <span class="st">&quot;page&quot;</span>) <span class="kw">do</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  h1_ <span class="st">&quot;Heading&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  div_</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    (class_ <span class="st">&quot;scroll&quot;</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      div_</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        ( <span class="fu">mconcat</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            [ tailSSE <span class="st">&quot;/stream&quot;</span>,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            , class_ <span class="st">&quot;stream-container&quot;</span>,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            , id_ <span class="st">&quot;stream-1&quot;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<p>The result here is somewhat mixed. Applying a single attribute isn’t too bad, but my main objection to this was that it’s inconsistent, and here it’s even more inconsistent - a single attribute uses parethesis, but multiple attributes need a call to <code>mconcat</code>. It is nice though that our <code>tailSSE</code> call no longer sticks out, and just looks like any other attribute.</p>
<h2 id="the-list-of-monoids-pattern">The list of monoids pattern</h2>
<p>With that setup, I can now present my solution - the list of monoids pattern. As the name suggests, the trick is to simply change our <code>Attributes</code> argument to now be a <code>[Attributes]</code>. This is essentially a list-of-lists of key-value pairs, which is probably not our first instinct when creating this API. However, I think it pays of when we try and lay out HTML using <code>lucid</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>div_ [ class_ <span class="st">&quot;page&quot;</span> ] <span class="kw">do</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  h1_ <span class="st">&quot;Heading&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  div_</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    [ class_ <span class="st">&quot;scroll&quot;</span> ]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      div_</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        [ tailSSE <span class="st">&quot;/stream&quot;</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        , class_ <span class="st">&quot;stream-container&quot;</span>,</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        , id_ <span class="st">&quot;stream-1&quot;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        ]</span></code></pre></div>
<p>We’re back to where we started! However, we’ve also retained a solution to the second example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ul_ <span class="kw">do</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  for_ items \item <span class="ot">-&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    li_</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      [ class_ <span class="st">&quot;p-4&quot;</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      , <span class="kw">if</span> active item <span class="kw">then</span> class_ <span class="st">&quot;font-bold&quot;</span> <span class="kw">else</span> <span class="fu">mempty</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      (toHTML (caption item))</span></code></pre></div>
<h2 id="lucid-could-go-further"><code>lucid</code> could go further</h2>
<p>Interestingly, once I had this observation I realised that <code>lucid</code> could actually go further. <code>Html a</code> is a <code>Monoid</code>, but notice that when we construct a <code>div_</code> we supply a single <code>Html a</code>. This post suggests that an alternative API is instead:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">div_ ::</span> [<span class="dt">Attributes</span>] <span class="ot">-&gt;</span> [<span class="dt">Html</span> a] <span class="ot">-&gt;</span> <span class="dt">Html</span> a</span></code></pre></div>
<p>Users of Elm might be getting a sense of déjà vu, as this is very similar to the type that Elm uses! I like this form because I think it makes HTML documents much more regular:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>div_</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  [ class_ <span class="st">&quot;p-4 font-bold&quot;</span> ]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  [ p_ <span class="st">&quot;Paragraph 1&quot;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  , img_ [ src_ <span class="st">&quot;haskell.gif&quot;</span> ]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  , p_ <span class="st">&quot;More&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>Elm falls short of the pattern advocated in this blog post, as both attributes and html elements lack an identity element, so while Elm uses lists, they aren’t lists of monoidal values.</p>
<h2 id="optparse-applicative"><code>optparse-applicative</code></h2>
<p>I want to briefly compare this to the API in <code>optparse-applicative</code>. <a href="https://twitter.com/GabriellaG439/status/1539325694991249408">Gabriella postulated</a> that <code>optparse-applicative</code> might be more approachable if it used records instead of its current monoidal based API. While I don’t disagree, I want to suggest that the list-of-monoids pattern here might also help.</p>
<p>When we use <code>optparse-applicative</code>, we often end up with code like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>flag</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>   ( long <span class="st">&quot;no-extensions&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">&lt;&gt;</span> short <span class="ch">'E'</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">&lt;&gt;</span> help <span class="st">&quot;Don't show the possible extensions for physical files&quot;</span> </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>   )</span></code></pre></div>
<p>Here we’re using a <code>&lt;&gt;</code> like a list. Unfortunately, this has two problems:</p>
<ul>
<li><p>Automatic code formatters already have a way to format lists, but they aren’t generally aware that we’re using <code>&lt;&gt;</code> as if it were constructing a list. This leads to either unexpected formatting, or special-casing within the formatter.</p></li>
<li><p>It’s less discoverable to new Haskell users that they can supply multiple values. Even an experienced Haskell user will likely have to look up the type and spot the <code>Monoid</code> instance.</p></li>
</ul>
<p>If <code>optparse-applicative</code> instead used a list of monoids, the API would be a little more succinct for users, while not losing any functionality:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>flag</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  [ long <span class="st">&quot;no-extensions&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  , short <span class="ch">'E'</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  , help <span class="st">&quot;Don't show the possible extensions for physical files&quot;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>Modifiers can be grouped and abstracted as before, and if we want to compute modifiers with an option to produce no modifiers at all, we can still return <code>mempty</code>. However users are no longer burdened with needing to combine modifiers using <code>&lt;&gt;</code>, and can instead lean on Haskell’s special syntax for lists.</p>
<h2 id="concluding-thoughts">Concluding thoughts</h2>
<p>If at this point you’re somewhat underwhelmed by this blog post, don’t worry! This pattern is extremely simple - there are no complex tricks required, it’s just literally wrapping things in a list, moving a call to <code>mconcat</code>, and you’re done. However, I think the implications are fairly significant, and I highly recommend you give this a try.</p>
<hr />
<p style="font-style: italic">You can contact me via email
at <a href="mailto:sudotoo@protonmail.com">sudotoo@protonmail.com</a> or tweet to
me <a href="http://twitter.com/otechai">@otechai</a>. I share almost all of my work
at <a href="http://github.com/fa5tworm">GitHub</a>.
  This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">post</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.</p>
<hr />

    <ul id="icons">
      <li>
        <a href="http://twitter.com/otechai">Twitter
          <img src="../img/twitter.ico" /></a></li>
      <li>
        <a href="https://github.com/fa5tworm">GitHub
          <img src="../img/github.ico" /></a></li>
      <li>
  </body>

</html>
